var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library-documentation-1","page":"Library documentation","title":"Library documentation","text":"","category":"section"},{"location":"lib/lib/#States-1","page":"Library documentation","title":"States","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"FiniteMPS\nInfiniteMPS\nMPSComoving\nMPSMultiline","category":"page"},{"location":"lib/lib/#MPSKit.FiniteMPS","page":"Library documentation","title":"MPSKit.FiniteMPS","text":"mutable struct FiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor} <: AbstractMPS\n\nRepresents a finite matrix product state\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.InfiniteMPS","page":"Library documentation","title":"MPSKit.InfiniteMPS","text":"struct InfiniteMPS{A<:GenericMPSTensor,B<:MPSBondTensor}\n\nRepresents an infinite matrix product state The state is stored in the centergauge where     state.AL[i]state.CR[i] = state.AC[i] = state.CR[i-1]state.AR[i]\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSComoving","page":"Library documentation","title":"MPSKit.MPSComoving","text":"MPSComoving(leftstate,window,rightstate)\n\nmuteable window of tensors on top of an infinite chain\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPSMultiline","page":"Library documentation","title":"MPSKit.MPSMultiline","text":"2d extension of InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Operators-1","page":"Library documentation","title":"Operators","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPOHamiltonian\nComAct\nPeriodicMPO","category":"page"},{"location":"lib/lib/#MPSKit.MPOHamiltonian","page":"Library documentation","title":"MPSKit.MPOHamiltonian","text":"MPOHamiltonian\n\nrepresents a general periodic quantum hamiltonian\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.ComAct","page":"Library documentation","title":"MPSKit.ComAct","text":"ComAct(ham1,ham2)\n\nActs on an mpo with mpo hamiltonian 'ham1' from below + 'ham2' from above.\nCan therefore represent the (anti) commutator.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PeriodicMPO","page":"Library documentation","title":"MPSKit.PeriodicMPO","text":"Represents a periodic (in 2 directions) statmech mpo\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Environments-1","page":"Library documentation","title":"Environments","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"MPSKit.AbstractInfEnv\nMPSKit.PerMPOInfEnv\nMPSKit.MPOHamInfEnv\nMPSKit.FinEnv\nMPSKit.SimpleEnv\nMPSKit.OvlEnv","category":"page"},{"location":"lib/lib/#MPSKit.AbstractInfEnv","page":"Library documentation","title":"MPSKit.AbstractInfEnv","text":"Abstract environment for an infinite state\ndistinct from finite, because we have to recalculate everything when the state changes\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.PerMPOInfEnv","page":"Library documentation","title":"MPSKit.PerMPOInfEnv","text":"This object manages the periodic mpo environments for an MPSMultiline\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.MPOHamInfEnv","page":"Library documentation","title":"MPSKit.MPOHamInfEnv","text":"This object manages the hamiltonian environments for an InfiniteMPS\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.FinEnv","page":"Library documentation","title":"MPSKit.FinEnv","text":"FinEnv keeps track of the environments for FiniteMPS / MPSComoving\nIt automatically checks if the queried environment is still correctly cached and if not - recalculates\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.SimpleEnv","page":"Library documentation","title":"MPSKit.SimpleEnv","text":"SimpleEnv does nothing fancy to ensure the correctness of the environments it returns.\nSupports setleftenv! and setrightenv!\nOnly used internally (in idmrg); no public constructor is provided\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Generic-actions-1","page":"Library documentation","title":"Generic actions","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"c_prime\nac_prime\nac2_prime\nexpectation_value","category":"page"},{"location":"lib/lib/#MPSKit.c_prime","page":"Library documentation","title":"MPSKit.c_prime","text":"Zero-site derivative (the C matrix to the right of pos)\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac_prime","page":"Library documentation","title":"MPSKit.ac_prime","text":"One-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.ac2_prime","page":"Library documentation","title":"MPSKit.ac2_prime","text":"Two-site derivative\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.expectation_value","page":"Library documentation","title":"MPSKit.expectation_value","text":"calculates the expectation value for the given operator/hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#Groundstate-algorithms-1","page":"Library documentation","title":"Groundstate algorithms","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"find_groundstate\nVumps\nIdmrg1\nDmrg\nDmrg2","category":"page"},{"location":"lib/lib/#MPSKit.find_groundstate","page":"Library documentation","title":"MPSKit.find_groundstate","text":"find_groundstate(state,ham,alg,pars=params(state,ham))\n\nfind the groundstate for ham using algorithm alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.Vumps","page":"Library documentation","title":"MPSKit.Vumps","text":"see https://arxiv.org/abs/1701.07035\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Idmrg1","page":"Library documentation","title":"MPSKit.Idmrg1","text":"onesite infinite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg","page":"Library documentation","title":"MPSKit.Dmrg","text":"onesite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Dmrg2","page":"Library documentation","title":"MPSKit.Dmrg2","text":"twosite dmrg\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Time-evolution-1","page":"Library documentation","title":"Time evolution","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"timestep\nTdvp\nTdvp2","category":"page"},{"location":"lib/lib/#MPSKit.timestep","page":"Library documentation","title":"MPSKit.timestep","text":"function timestep(psi, operator, dt, alg,parameters = params(psi,operator))\n\ntime evolves psi by timestep dt using algorithm alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.Tdvp","page":"Library documentation","title":"MPSKit.Tdvp","text":"onesite tdvp\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#MPSKit.Tdvp2","page":"Library documentation","title":"MPSKit.Tdvp2","text":"twosite tdvp (works for finite mps's)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#Bond-dimension-code-1","page":"Library documentation","title":"Bond dimension code","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"changebonds\nmanagebonds","category":"page"},{"location":"lib/lib/#MPSKit.changebonds","page":"Library documentation","title":"MPSKit.changebonds","text":"Change the bond dimension of state using alg\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.managebonds","page":"Library documentation","title":"MPSKit.managebonds","text":"Manage (grow or shrink) the bond dimsions of state using manager 'alg'\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#Various-1","page":"Library documentation","title":"Various","text":"","category":"section"},{"location":"lib/lib/#","page":"Library documentation","title":"Library documentation","text":"dynamicaldmrg\nquasiparticle_excitation","category":"page"},{"location":"lib/lib/#MPSKit.dynamicaldmrg","page":"Library documentation","title":"MPSKit.dynamicaldmrg","text":"https://arxiv.org/pdf/cond-mat/0203500.pdf\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#MPSKit.quasiparticle_excitation","page":"Library documentation","title":"MPSKit.quasiparticle_excitation","text":"quasiparticle_excitation calculates the energy of the first excited state at momentum 'moment'\n\n\n\n\n\n","category":"function"},{"location":"man/states/#um_states-1","page":"States","title":"States","text":"","category":"section"},{"location":"man/states/#FiniteMPS-1","page":"States","title":"FiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"A finite mps can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^1*ℂ^2,ℂ^1),10);\nFiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Or alternatively by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"len = 10;\nmax_bond_dimension = ℂ^10;\nphysical_space = ℂ^2;\nFiniteMPS(rand,ComplexF64,len,physical_space,max_bond_dimension);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can take dot products, renormalize!, expectation values,....","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In our algorithms we typically make use of the fields .AC/.AR/.AL. Calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AC[3]","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"gauges the state such that every tensor left of 3 is a left unitary matrix and to the right we have right unitary matrices. As a result you should have","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Note that every tensor should be a map from the virtual space to the virtual space ⊗ physical space. In other words, we need the input tensormaps to be of the type AbstractTensorMap{S,N,1}.","category":"page"},{"location":"man/states/#InfiniteMPS-1","page":"States","title":"InfiniteMPS","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"An infinite mps can be created by passing in a vector of tensormaps:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2);\nInfiniteMPS(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"The above code would create an infinite mps with an A-B structure (a 2 site unit cell).","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Very analogous to the finite mps case we have:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"norm(state) == norm(state.AC[3])","category":"page"},{"location":"man/states/#MPSComoving-1","page":"States","title":"MPSComoving","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"MPSComoving is a bit of a mix between an infinite mps and a finite mps. It represents a window of mutable tensors embedde in an infinite mps.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"It can be created using:","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"mpco = MPSComoving(left_infinite_mps,window_of_tensors,right_infinite_mps)","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Algorithms will then act on this window of tensors, while leaving the left and right infinite mps'es invariant.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"This state can be used to study impurities or local quenches.","category":"page"},{"location":"man/states/#MPSMultiline-1","page":"States","title":"MPSMultiline","text":"","category":"section"},{"location":"man/states/#","page":"States","title":"States","text":"Statistical physics partition functions can be represented by an infinite tensor network which then needs to be contracted. This is done by finding approximate fixpoint infinite matrix product states. However, there is no good reason why a single mps should suffice and indeed we find in practice that this can also be periodic.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"In other words, the fixpoints can be well described by a set of matrix product states.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"Such a set can be created by","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"data = fill(TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10),2,2);\nMPSMultiline(data);","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"MPSMultiline is also used extensively in as of yet unreleased peps code.","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"You can access properties by calling","category":"page"},{"location":"man/states/#","page":"States","title":"States","text":"state.AL[row,collumn]","category":"page"},{"location":"man/intro/#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"The following few sections should help you on your way to setting up and running simulations.","category":"page"},{"location":"man/intro/#TensorKit-1","page":"Basics","title":"TensorKit","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"MPSKit works on \"TensorMap\" objects defined in TensorKit.jl. These abstract objects can represent not only plain arrays but also symmetric tensors. A TensorMap is a linear map from its domain to its codomain.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Initializing a TensorMap can be done using","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(initializer,eltype,codomain,domain);\nTensorMap(inputdat,codomain,domain);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As an example, the following creates a random map from ℂ^10 to ℂ^10 (which is equivalent to a random matrix)","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\ndat = rand(ComplexF64,10,10); TensorMap(dat,ℂ^10,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Similarly, the following creates a symmetric tensor","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorMap(rand,ComplexF64,ℂ[U₁](0=>1)*ℂ[U₁](1//2=>3),ℂ[U₁](1//2=>1,-1//2=>2))","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"TensorKit defines a number of operations on TensorMap objects","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n3*a; a+a; a*a; a*adjoint(a); a-a; dot(a,a); norm(a);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"but the primary workhorse is the @tensor macro","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\nb = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n@tensor c[-1;-2]:=a[-1,1]*b[1,-2];","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"creates a new TensorMap c equal to a*b.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"For more information, check out the tensorkit documentation!","category":"page"},{"location":"man/intro/#Overview-1","page":"Basics","title":"Overview","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"Within MPSKit we defined a set of states, a number of operators and some algorithms which combine the two in a nontrivial way.","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"As a simple example we can define a FiniteMPS","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"state = FiniteMPS(rand,ComplexF64,10,ℂ^2,ℂ^10);","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"A hamiltonian operator","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"opp = nonsym_ising_ham();","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"And use this to find the groundstate","category":"page"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"(groundstate,_) = find_groundstate(state,opp,DMRG());","category":"page"},{"location":"man/intro/#Tips-and-tricks-1","page":"Basics","title":"Tips & tricks","text":"","category":"section"},{"location":"man/intro/#","page":"Basics","title":"Basics","text":"There is an examples folder\nJulia inference is taxed a lot; so use (jupyter notebooks / Revise ) instead of re-running a script everytime","category":"page"},{"location":"man/algorithms/#um_algorithms-1","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithms/#find_groundstate-1","page":"Algorithms","title":"find_groundstate","text":"","category":"section"},{"location":"man/algorithms/#timestep-1","page":"Algorithms","title":"timestep","text":"","category":"section"},{"location":"man/algorithms/#dynamicaldmrg-1","page":"Algorithms","title":"dynamicaldmrg","text":"","category":"section"},{"location":"man/operators/#um_operators-1","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/operators/#MPOHamiltonian-1","page":"Operators","title":"MPOHamiltonian","text":"","category":"section"},{"location":"man/operators/#PeriodicMPO-1","page":"Operators","title":"PeriodicMPO","text":"","category":"section"},{"location":"man/operators/#ComAct-1","page":"Operators","title":"ComAct","text":"","category":"section"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This code track contains the numerical research and development of the Ghent Quantum Group with regard to tensor network simulation in the julia language. The purpose of this package is to facilitate efficient collaboration between different members of the group.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Topics of research on tensor networks within the realm of this track include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tensor network algorithms (excitations, tdvp, vumps, ...)\nMPS routines (MPS diagonalization, Schmidt Decomposition, MPS left and right multiplication, ...)\nThe study of several useful models (nearest neighbour interactions, MPO's, long range interactions, ...)","category":"page"},{"location":"#User-manual-1","page":"Home","title":"User manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\",\"man/states.md\",\"man/operators.md\",\"man/algorithms.md\"]\nDepth = 3","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/lib.md\"]\nDepth = 1","category":"page"}]
}
