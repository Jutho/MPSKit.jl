var documenterSearchIndex = {"docs":
[{"location":"#MPSKit.jl-documentation-1","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"This code track contains the numerical research and development of the Ghent Quantum Group with regard to tensor network simulation in the julia language. The purpose of this package is to facilitate efficient collaboration between different members of the group.","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"Topics of research on tensor networks within the realm of this track include:","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"Tensor network algorithms (excitations, tdvp, vumps, ...)\nMPS routines (MPS diagonalization, Schmidt Decomposition, MPS left and right multiplication, ...)\nThe study of several useful models (nearest neighbour interactions, MPO's, long range interactions, ...)","category":"page"},{"location":"#Basics-1","page":"MPSKit.jl documentation","title":"Basics","text":"","category":"section"},{"location":"#TensorMap-1","page":"MPSKit.jl documentation","title":"TensorMap","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"mpskit works on \"TensorMap\" objects defined in TensorKit.jl (a different package). These abstract objects can represent not only plain arrays but also symmetric tensors. A TensorMap is a linear map from its domain to its codomain.","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"Initializing a TensorMap can be done using","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"TensorMap(initializer,eltype,codomain,domain);\nTensorMap(inputdat,codomain,domain);","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"As an example, the following creates a random map from ℂ^10 to ℂ^10 (which is equivalent to a random matrix)","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\ndat = rand(ComplexF64,10,10); TensorMap(dat,ℂ^10,ℂ^10);","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"Similarly, the following creates a symmetric tensor","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"TensorMap(rand,ComplexF64,ℂ[U₁](0=>1)*ℂ[U₁](1//2=>3),ℂ[U₁](1//2=>1,-1//2=>2))","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"TensorKit defines a number of operations on TensorMap objects","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n3*a; a+a; a*a; a*adjoint(a); a-a; dot(a,a); norm(a);","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"but the primary workhorse is the @tensor macro","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\nb = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);\n@tensor c[-1;-2]:=a[-1,1]*b[1,-2];","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"creates a new TensorMap c equal to a*b.","category":"page"},{"location":"#states-1","page":"MPSKit.jl documentation","title":"states","text":"","category":"section"},{"location":"#Uniform-Mps-1","page":"MPSKit.jl documentation","title":"Uniform Mps","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"An mps tensor is defined as a TensorMap from the bond dimension space (D) to bond dimension space x physical space (D x d). A uniform mps representing ... ABABAB... can be created using","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"A = TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10);\nB = TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10);\nMpsCenterGauged([A,B]);","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"This MpsCenterGauged structure has the fields AL,AR,AC,CR where AL[i]CR[i]=CR[i-1]AR[i]=AC[i] and AL/AR is left/right unitary.","category":"page"},{"location":"#FiniteMps-1","page":"MPSKit.jl documentation","title":"FiniteMps","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"A finite mps is an array of mps tensors starting with bond dimension 1 and ending with bond dimension 1","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"A = TensorMap(rand,ComplexF64,ℂ^1*ℂ^2,ℂ^2);\nB = TensorMap(rand,ComplexF64,ℂ^2*ℂ^2,ℂ^2);\nC = TensorMap(rand,ComplexF64,ℂ^2*ℂ^2,ℂ^1);\nFiniteMps([A,B,C]);","category":"page"},{"location":"#MpsComoving-1","page":"MPSKit.jl documentation","title":"MpsComoving","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"When doing local quenches in a uniform state, we only need to time evolve a \"window\" of tensors. MpsComoving(stateleft,window,stateright) creates such a set of states, and can be passed to find_groundstate() or timestep(). Another possible use is to study the effect of impurities.","category":"page"},{"location":"#Operators-1","page":"MPSKit.jl documentation","title":"Operators","text":"","category":"section"},{"location":"#MpoHamiltonian-1","page":"MPSKit.jl documentation","title":"MpoHamiltonian","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"MpoHamiltonian is a hamiltonian in the mpo representation. As an example, this creates the spin 1 heisenberg :","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"(sx,sy,sz,id) = nonsym_spintensors(1)\n\n@tensor tham[-1 -2;-3 -4]:=sx[-1,-3]*sx[-2,-4]+sy[-1,-3]*sy[-2,-4]+sz[-1,-3]*sz[-2,-4]\nham = MpoHamiltonian(tham)","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"This code is already included in the juliatrack, just call","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"nonsym_xxz_ham();","category":"page"},{"location":"#periodic-mpo-1","page":"MPSKit.jl documentation","title":"periodic mpo","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"PeriodicMpo is a periodic nxm array of matrix product operators, intended to be used for classical statmech problems.","category":"page"},{"location":"#Algorithms-1","page":"MPSKit.jl documentation","title":"Algorithms","text":"","category":"section"},{"location":"#find-groundstate-1","page":"MPSKit.jl documentation","title":"find groundstate","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"To find the groundstate of a given state (be it a uniform mps or a finite mps), just call","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"find_groundstate(state,hamiltonian,algorithm);","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"where algorithm can be Vumps(),Dmrg(),.... As an example, the following code finds the groundstate of spin-1 heisenberg:","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"ham = nonsym_xxz_ham();\nst = MpsCenterGauged([TensorMap(rand,ComplexF64,ComplexSpace(10)*ComplexSpace(3),ComplexSpace(10))]);\nfind_groundstate(st,ham,Vumps());","category":"page"},{"location":"#timestep-1","page":"MPSKit.jl documentation","title":"timestep","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"timestep(state,hamiltonian,dt,algorithm);","category":"page"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"evolves state forward in time by dt. Algorithm can be either Tdvp() or Tdvp2().","category":"page"},{"location":"#Tips-and-tricks-1","page":"MPSKit.jl documentation","title":"Tips & tricks","text":"","category":"section"},{"location":"#","page":"MPSKit.jl documentation","title":"MPSKit.jl documentation","text":"More information can be found in the documentation, provided someone writes it first.\nThere is an examples folder\nJulia inference is taxed a lot; so use jupyter notebooks instead of re-running a script everytime","category":"page"}]
}
