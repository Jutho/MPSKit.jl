<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MPSKit.jl documentation · My Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">My Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MPSKit.jl documentation</a><ul class="internal"><li><a class="tocitem" href="#Basics-1"><span>Basics</span></a></li><li><a class="tocitem" href="#states-1"><span>states</span></a></li><li><a class="tocitem" href="#Operators-1"><span>Operators</span></a></li><li><a class="tocitem" href="#Algorithms-1"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Tips-and-tricks-1"><span>Tips &amp; tricks</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MPSKit.jl documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MPSKit.jl documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maartenvd/MPSKit.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MPSKit.jl-documentation-1"><a class="docs-heading-anchor" href="#MPSKit.jl-documentation-1">MPSKit.jl documentation</a><a class="docs-heading-anchor-permalink" href="#MPSKit.jl-documentation-1" title="Permalink"></a></h1><p>This code track contains the numerical research and development of the Ghent Quantum Group with regard to tensor network simulation in the julia language. The purpose of this package is to facilitate efficient collaboration between different members of the group.</p><p>Topics of research on tensor networks within the realm of this track include:</p><ul><li>Tensor network algorithms (excitations, tdvp, vumps, ...)</li><li>MPS routines (MPS diagonalization, Schmidt Decomposition, MPS left and right multiplication, ...)</li><li>The study of several useful models (nearest neighbour interactions, MPO&#39;s, long range interactions, ...)</li></ul><h2 id="Basics-1"><a class="docs-heading-anchor" href="#Basics-1">Basics</a><a class="docs-heading-anchor-permalink" href="#Basics-1" title="Permalink"></a></h2><h3 id="TensorMap-1"><a class="docs-heading-anchor" href="#TensorMap-1">TensorMap</a><a class="docs-heading-anchor-permalink" href="#TensorMap-1" title="Permalink"></a></h3><p>mpskit works on &quot;TensorMap&quot; objects defined in TensorKit.jl (a different package). These abstract objects can represent not only plain arrays but also symmetric tensors. A TensorMap is a linear map from its domain to its codomain.</p><p>Initializing a TensorMap can be done using</p><pre><code class="language-julia">TensorMap(initializer,eltype,codomain,domain);
TensorMap(inputdat,codomain,domain);</code></pre><p>As an example, the following creates a random map from ℂ^10 to ℂ^10 (which is equivalent to a random matrix)</p><pre><code class="language-julia">TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);
dat = rand(ComplexF64,10,10); TensorMap(dat,ℂ^10,ℂ^10);</code></pre><p>Similarly, the following creates a symmetric tensor</p><pre><code class="language-julia">TensorMap(rand,ComplexF64,ℂ[U₁](0=&gt;1)*ℂ[U₁](1//2=&gt;3),ℂ[U₁](1//2=&gt;1,-1//2=&gt;2))</code></pre><p>TensorKit defines a number of operations on TensorMap objects</p><pre><code class="language-julia">a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);
3*a; a+a; a*a; a*adjoint(a); a-a; dot(a,a); norm(a);</code></pre><p>but the primary workhorse is the @tensor macro</p><pre><code class="language-julia">a = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);
b = TensorMap(rand,ComplexF64,ℂ^10,ℂ^10);
@tensor c[-1;-2]:=a[-1,1]*b[1,-2];</code></pre><p>creates a new TensorMap c equal to a*b.</p><h2 id="states-1"><a class="docs-heading-anchor" href="#states-1">states</a><a class="docs-heading-anchor-permalink" href="#states-1" title="Permalink"></a></h2><h3 id="Uniform-Mps-1"><a class="docs-heading-anchor" href="#Uniform-Mps-1">Uniform Mps</a><a class="docs-heading-anchor-permalink" href="#Uniform-Mps-1" title="Permalink"></a></h3><p>An mps tensor is defined as a TensorMap from the bond dimension space (D) to bond dimension space x physical space (D x d). A uniform mps representing ... ABABAB... can be created using</p><pre><code class="language-julia">A = TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10);
B = TensorMap(rand,ComplexF64,ℂ^10*ℂ^2,ℂ^10);
MpsCenterGauged([A,B]);</code></pre><p>This MpsCenterGauged structure has the fields AL,AR,AC,CR where AL[i]CR[i]=CR[i-1]AR[i]=AC[i] and AL/AR is left/right unitary.</p><h3 id="FiniteMps-1"><a class="docs-heading-anchor" href="#FiniteMps-1">FiniteMps</a><a class="docs-heading-anchor-permalink" href="#FiniteMps-1" title="Permalink"></a></h3><p>A finite mps is an array of mps tensors starting with bond dimension 1 and ending with bond dimension 1</p><pre><code class="language-julia">A = TensorMap(rand,ComplexF64,ℂ^1*ℂ^2,ℂ^2);
B = TensorMap(rand,ComplexF64,ℂ^2*ℂ^2,ℂ^2);
C = TensorMap(rand,ComplexF64,ℂ^2*ℂ^2,ℂ^1);
FiniteMps([A,B,C]);</code></pre><h3 id="MpsComoving-1"><a class="docs-heading-anchor" href="#MpsComoving-1">MpsComoving</a><a class="docs-heading-anchor-permalink" href="#MpsComoving-1" title="Permalink"></a></h3><p>When doing local quenches in a uniform state, we only need to time evolve a &quot;window&quot; of tensors. MpsComoving(state<em>left,window,state</em>right) creates such a set of states, and can be passed to find_groundstate() or timestep(). Another possible use is to study the effect of impurities.</p><h2 id="Operators-1"><a class="docs-heading-anchor" href="#Operators-1">Operators</a><a class="docs-heading-anchor-permalink" href="#Operators-1" title="Permalink"></a></h2><h3 id="MpoHamiltonian-1"><a class="docs-heading-anchor" href="#MpoHamiltonian-1">MpoHamiltonian</a><a class="docs-heading-anchor-permalink" href="#MpoHamiltonian-1" title="Permalink"></a></h3><p>MpoHamiltonian is a hamiltonian in the mpo representation. As an example, this creates the spin 1 heisenberg :</p><pre><code class="language-julia">(sx,sy,sz,id) = nonsym_spintensors(1)

@tensor tham[-1 -2;-3 -4]:=sx[-1,-3]*sx[-2,-4]+sy[-1,-3]*sy[-2,-4]+sz[-1,-3]*sz[-2,-4]
ham = MpoHamiltonian(tham)</code></pre><p>This code is already included in the juliatrack, just call</p><pre><code class="language-julia">nonsym_xxz_ham();</code></pre><h3 id="periodic-mpo-1"><a class="docs-heading-anchor" href="#periodic-mpo-1">periodic mpo</a><a class="docs-heading-anchor-permalink" href="#periodic-mpo-1" title="Permalink"></a></h3><p>PeriodicMpo is a periodic nxm array of matrix product operators, intended to be used for classical statmech problems.</p><h2 id="Algorithms-1"><a class="docs-heading-anchor" href="#Algorithms-1">Algorithms</a><a class="docs-heading-anchor-permalink" href="#Algorithms-1" title="Permalink"></a></h2><h3 id="find-groundstate-1"><a class="docs-heading-anchor" href="#find-groundstate-1">find groundstate</a><a class="docs-heading-anchor-permalink" href="#find-groundstate-1" title="Permalink"></a></h3><p>To find the groundstate of a given state (be it a uniform mps or a finite mps), just call</p><pre><code class="language-julia">find_groundstate(state,hamiltonian,algorithm);</code></pre><p>where algorithm can be Vumps(),Dmrg(),.... As an example, the following code finds the groundstate of spin-1 heisenberg:</p><pre><code class="language-julia">ham = nonsym_xxz_ham();
st = MpsCenterGauged([TensorMap(rand,ComplexF64,ComplexSpace(10)*ComplexSpace(3),ComplexSpace(10))]);
find_groundstate(st,ham,Vumps());</code></pre><h3 id="timestep-1"><a class="docs-heading-anchor" href="#timestep-1">timestep</a><a class="docs-heading-anchor-permalink" href="#timestep-1" title="Permalink"></a></h3><pre><code class="language-julia">timestep(state,hamiltonian,dt,algorithm);</code></pre><p>evolves state forward in time by dt. Algorithm can be either Tdvp() or Tdvp2().</p><h2 id="Tips-and-tricks-1"><a class="docs-heading-anchor" href="#Tips-and-tricks-1">Tips &amp; tricks</a><a class="docs-heading-anchor-permalink" href="#Tips-and-tricks-1" title="Permalink"></a></h2><ul><li>More information can be found in the documentation, provided someone writes it first.</li><li>There is an examples folder</li><li>Julia inference is taxed a lot; so use jupyter notebooks instead of re-running a script everytime</li></ul></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 3 February 2020 15:04">Monday 3 February 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
